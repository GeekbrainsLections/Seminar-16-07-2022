# **Инструкция по работе с Git**

## **Что такое Git?**
>**Git** - это консольная утилита, для отслеживания и ведения истории изменения файлов, в вашем проекте. Чаще всего его используют для кода, но можно и для других файлов. Например, для картинок - полезно для дизайнеров.
С помощью **Git**-a вы можете откатить свой проект до более старой версии, сравнивать, анализировать или сливать свои изменения в репозиторий.
Репозиторием называют хранилище вашего кода и историю его изменений. **Git** работает локально и все ваши репозитории хранятся в определенных папках на жестком диске.
Так же ваши репозитории можно хранить и в интернете. 
## **Подготовка репозитория**.
>Для создания нового репозитория используется команда **git init**. Команду **git init** выполняют только один раз для первоначальной настройки нового репозитория. Выполнение команды приведет к созданию нового подкаталога **.git** в вашем рабочем каталоге. Кроме того, будет создана новая главная ветка.
Если проект уже настроен в центральном репозитории, наиболее распространенным способом создать его локальный клон является команда **clone**. Клонирование, как и команда **git init**, обычно выполняется один раз. Получив рабочую копию, разработчик в дальнейшем выполняет все операции контроля версий из своего локального репозитория.
## **Создание "сохранений"**.
>Команда git add — это первая команда в цепочке операций, предписывающей Git «сохранить» снимок текущего состояния проекта в истории коммитов. Когда git add используется как отдельная команда, она переносит ожидающие изменения из рабочего каталога в раздел проиндексированных файлов. Команда git status проверяет текущее состояние репозитория; с ее помощью можно убедиться, что команда git add добавила нужные изменения. Команда git reset используется для отмены команды git add. Команда git commit сохраняет снимок состояния из раздела проиндексированных файлов в истории коммитов репозитория.
## **Перемещение между "сохранениями"**.
>Команда git checkout часто используется вместе с командой git branch. С помощью команды git branch можно создать новую ветку. Когда вы захотите начать работу над новой функцией, создайте новое ответвление от ветки main с помощью команды git branch new_branch. Затем переключитесь на новую ветку с помощью команды git checkout new_branch. Команда git checkout также принимает аргумент -b, который действует как вспомогательный метод, позволяя создать новую ветку и сразу переключиться на нее. Вы можете работать сразу с несколькими функциями в одном репозитории, переключаясь между ними с помощью git checkout.
## **Журнал изменений**
>Команда git log отображает отправленные снимки состояния и позволяет просматривать и фильтровать историю проекта, а также искать в ней конкретные изменения. С помощью git status можно просматривать рабочий каталог и раздел проиндексированных файлов, в то время как git log показывает только историю коммитов.
## **Ветки в Git**.
>Команду git branch главным образом используют для создания, просмотра, переименования и удаления веток.
## **Слияние веток и решение конфликтов**.
>Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.
Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд git stash, git checkout, git commit или git reset.
Сбой В ПРОЦЕССЕ слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную.
Команда git status часто используется во время работы с Git и помогает идентифицировать конфликтующие во время слияния файлы.
git log --merge. При передаче аргумента --merge для команды git log будет создан журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние.
Команда git diff помогает найти различия между состояниями репозитория/файлов. Она полезна для выявления и предупреждения конфликтов слияния.
## **Удаление веток**.
* ***git branch -d Name_branch*** - удаление указанной ветки. Это «безопасная» операция, поскольку Git не позволит удалить ветку, если в ней есть неслитые изменения.
* ***git branch -D Name_branch*** - принудительное удаление указанной ветки, даже если в ней есть неслитые изменения. Эта команда используется, если вы хотите навсегда удалить все коммиты, связанные с определенным направлением разработки.
* ***git branch -m Name_branch*** - изменение имени текущей ветки на Name_branch.
* ***git branch -a*** - вывод списка всех удаленных веток.
# ***Работа с удаленным репозиторием***
## **git fetch**
>Команда ***git fetch*** связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально. Например ***git fetch origin***
Рассмотренная команда ***git fetch*** — это основная команда, которая используется для загрузки содержимого из удаленного репозитория. Чтобы обновить локальный репозиторий до состояния удаленного репозитория, команда ***git fetch*** используется в сочетании с командами ***git remote***, ***git branch***, ***git checkout*** и ***git reset***. Команда ***git fetch*** представляет собой важную часть рабочих процессов, связанных с совместной работой в Git. Поведение ***git fetch*** сходно с поведением команды ***git pull***, однако ***git fetch*** можно считать более безопасным вариантом без разрушения информации.
## **git pull**
>Команда ***git pull*** используется для извлечения и загрузки содержимого из удаленного репозитория и немедленного обновления локального репозитория этим содержимым. Слияние удаленных вышестоящих изменений в локальный репозиторий — это обычная задача рабочего процесса, возникающая при совместной работе на основе системы Git. Команда ***git pull*** на самом деле представляет собой комбинацию двух других команд: ***git fetch*** и ***git merge***. На первом этапе ***git pull*** выполняется команда ***git fetch***, ограниченная локальной веткой, на которую указывает **HEAD**. Сразу после загрузки содержимого команда ***git pull*** выполняет слияние. Для слитого содержимого создается новый коммит, а указатель **HEAD** обновляется и начинает указывать на этот новый коммит.
1. **git pull < remote >**
>Извлечь из указанного удаленного репозитория копию текущей ветки и немедленно слить ее с локальной копией. Эта команда аналогична команде ***git fetch < удаленный-репозиторий >***, после которой следует команда ***git merge origin/< текущая-ветка >***.
2. **git pull --no-commit < remote>**
>Подобно вызову по умолчанию, извлекает удаленное содержимое, но не создает новый коммит со слитым содержимым.
3. **git pull --rebase < remote >**
>Аналогично предыдущей команде **pull**, только вместо команды ***git merge*** для интеграции удаленной ветки с локальной веткой используется команда ***git rebase***.
4. **git pull --verbose**
>Во время выполнения команды **pull** выдает подробный вывод о загружаемом содержимом и информацию о слиянии.
## **git push**
>Команда ***git push*** используется для выгрузки содержимого локального репозитория в удаленный репозиторий. Она позволяет передать коммиты из локального репозитория в удаленный. Эта команда симметрична команде ***git fetch***: при извлечении с помощью **fetch** коммиты импортируются в локальные ветки, а при публикации с помощью **push** коммиты экспортируются в удаленные ветки. Настроить удаленные ветки можно с помощью команды ***git remote***. Команда **push** может перезаписать изменения, поэтому при ее использовании следует соблюдать осторожность.
1. **git push < remote > < branch >**
>Публикация указанной ветки в удаленном репозитории вместе со всеми необходимыми коммитами и внутренними объектами. Эта команда создает локальную ветку в репозитории назначения. Чтобы предотвратить перезапись коммитов, Git не позволит опубликовать данные, если в репозитории назначения нельзя выполнить ускоренное слияние.
2. **git push < remote > --force**
>Аналогично приведенной выше команде, однако данные будут опубликованы принудительно, даже если нельзя выполнить ускоренное слияние. Не используйте флаг ***--force***, если вы не уверены в своих действиях.
3. **git push < remote > --all**
>Публикация всех локальных веток в указанном удаленном репозитории.
4. **git push < remote > --tags**
>При публикации ветки или использовании опции ***--all*** теги не публикуются автоматически. Флаг ***--tags*** отправляет все локальные теги в удаленный репозиторий.
## **git remote**
>Команда ***git remote*** позволяет создавать, просматривать и удалять подключения к другим репозиториям. Удаленные подключения скорее похожи на закладки, чем на прямые ссылки на другие репозитории. Они служат удобными именами, с помощью которых можно сослаться на не очень удобный URL-адрес, а не предоставляют доступ к другому репозиторию в режиме реального времени. Например ***git remote add (name) (url)***
1. **git remote**
>Список ваших удаленных подключений к другим репозиториям.
2. **git remote -v**
>Аналогично команде выше, но включает URL-адрес каждого подключения.
3. **git remote add < name > < url >**
>Создание нового подключения к удаленному репозиторию. После добавления удаленного репозитория имя **＜name＞** можно использовать в качестве удобного ярлыка для адреса **＜url＞** в других командах Git.
4. **git remote rm < name >**
>Удаление подключения к удаленному репозиторию с именем **＜name＞**.
5. **git remote rename < old-name > < new-name >**
>Переименование удаленного подключения с имени **＜old-name＞** на **＜new-name＞**.
---