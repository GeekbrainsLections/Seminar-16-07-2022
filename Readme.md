# **Домашнее задание от Семинара-2 (от 11.07.2022) к предмету Контроль версий** _с дополнением к Семинару от 16.07.2022_.

Студент: **_Кудряшов Александр_**

## Домашнее задание:

1. сделать Форк репозитория Олега по Семинару от 16.07.2022
2. Внести изменения - дописать команды, которые ещё не описаны в Инструкции.
3. Всё выполнить желательно в отдельной ветке.
4. Послать Pull Request.


# Инструкция по работе с git и удалёнными репозиториями

## Что такое git?
*Git* одна из реализаций распредённых систем контроля версий. *Git* на данный момент является самой полулярной реализацией. Самой популярной реализацией *Git* является [GitHub](https://github.com) 

## Подготовка репозитория
Для того, чтобы создать репозиторий используется команда *git init*. Для этого необходимо написать в терминале в папке будущего репозитория *git init* и эта папка станет репозиторием.

### Просмотр состояния репозиториев

Для того, чтобы посмотреть состояние репозитория, используется команда *git status* Для этого в терминале с папкой-репозиторием необходмо написать *git status*, и возможно увидеть несколько состояний:
1. Nothing to commit - репозиторий не содержит изменений
2. Unversioned file - папка содержит файл, к которому не добавлена версионность


# Просмотр сделанных изменений
Для того, чторбы просмотреть разницу между текущей версией файла, и версией файла в полследнем коммите, используется команда *git diff*. Для этого в терминале с папкой с репозиторием, напишите *git diff*

### Добавление файла к коммиту

Для добавления файла к коммиту используется команда *git add*. Пишется она следующим образом *git add <имя файла>* в терминале в папке с созданным репозиторием.

### Создание нового коммита

Создание комитов - это одна из основных задач программы Git -  периодически выполняя сохранения рабочего материала (редактируемого файла, программного кода), с помощью команды Ctr+S в редакторе VisualStudio Code и затем выполняя две команды Git (git add filename и git commit -m "Commit message"), мы можем сохранять различные стадии/версии результатов нашей работы. Сообщение "Commit message", указываемое во второй команде - это информация, которая позволяет видеть какое именно изменение мы вносили на определённой стадии/версии нашего рабочего файла, и, при необходимости, по этому комментарию мы можем найти эту версию и "откатиться" к ней". 

## Журнал изменений
Для просмотра журнала измений используется команда *git log*. Для этого в терминале в папке с репозиторием достаточно написать *git log*

## Перемещение между "сохранениями"
Для перемещения между сохранениями используется команда *git checkout*. Для того, чтобы перемиститься на указанный коммит в терминале в папке с репозиторием пишем *git checkout <номер коммита>*. **Номер коммита** берется из журнала изменений, о котором сказано выше. После перемещния на указанный коммит мы попадаем в состояние **detached head*. Чтобы вернуться к обычной работе, необходимо написать *git checkout master*.

## Ветки в git
В программе Git есть возможность создания дополнительных версий рабочего файла, так называемых "веток". Обозначение "ветка" очень точно отображает суть формата создаваемой дополнительной версии файла, т.к. осноная версия файла не меняется в момент создания и развития новой версии или "ветки". Это также удобно для групповой работы в одном рабочем файле, когда можно отследить действия автора новой ветки, и иметь возможность согласовать новую версию с лидером (хозяином) основной редакции файла.

Для создания новой ветки необходимо выполнить команду <git branch>, чтобы увидеть какие вообще ветки редактируемого файла существуют в данный момент.

Данная команда отобразит список уже созданных веток, а также сообщит пользователю в какой ветке он находится. 

Создание новой ветки выполняется командой "*git branch NewBranchName*", где "NewBranchName" - это произвольное наименование вновь создаваемой ветки. При создании новой ветки, в её содержимое войдет полная копия ветки, в которой находится пользователь в момент создания новой ветки (по умолчанию это скорее всего ветка Master, но не обязательно).

После создания новой ветки необходим в неё переместиться с помощью команды "*git checkout NewBranchName*", и проверить командами "*git branch*", "*git status*", действительно ли пользователь туда переместился.

Далее пользователь может спокойно выполнять редактирование новой ветки, и выполнять коммиты, с целью сохранения всех этапов выполняемой работы.


## Слияние веток и разрешение конфликтов
При завершении работы в отдельной ветке и наличии полной уверенности в готовности подготовленных доработок для включения их в основную ветку рабочей версии файла, необходимо выполнить команду слияния - т.е. "залить" данные, созданные в этой ветке в основную (т.е. в ветку master).

Слияние запускается следующей командой: "*git merge BranchName*", где BranchName - это наименование ветки, данные которой необходимо "залить" в ветку master.
Очень важно, перед запуском команды - перейти в ветку master, и после перехода - нужно убедиться, что этот переход состоялся с помощью команд "*git branch*", "*git status*".
Команда "*git merge*" выполняет перенос данных в ту ветку, в которой находится пользователь из той ветки, которая указана в команде слияния, т.е. BranchName.

Бывают ситуации, когда в процесе слияния информация, "заливаемая" в текущую ветку отличается от имеющейся информации в текущей ветки. Это создаёт конфликт, т.к. функция слияния расчитана за закачку новой информации. При закачке подобных данных, но имеющих отличия, программа git видит эти различия, и отображает на экране ситуацию конфликта - т.е. наличия двух версий одного и того же текста (это не отностися к новой части текста). В этом случае программа Git предлагает пользователю несколько вариантов действий - обе, конфликтующие между собой версии текста заключаются в особые знаки (знаки "равно" ===== и текст HEAD в верхнеей части выделенного текста обеих версий), над этими, выделенными частями появляется меню из нескольких опций, одну из которых можно выбрать кликнув мышкой: 
* принять текущие данные но не принимать закачиваемые данные
* принять новые данные и удалить текущие данные
* принять обе версии текста
* сравнить версии текста.

Наиболее оптимальным вариантом является ручное решение конфликта: вручную отредактировать текст, оставив ту редакцию, которая по мнению пользователя должна остаться в итоге, и вручную удалить ненужный текст, а также необходимо удалить новые символы, выделяющие возникшую зону конфликта в тексте. После выполнения указанных изменений текста - выполнить сохранение командой Сtrl+S, затем выполнить коммит, где указываем, что завершили слияние с определенной веткой.


## Удаление веток
Для удаления ветки используется команда *git branch -d*. Для этого необходимо в папке с репозиторием в терминале написать *git branch -d <название ветки>*. Удаляемая ветка **ОБЯЗАТЕЛЬНО** должна быть **СЛИТА**

## Получение удалённого репозитория
Для того, чтобы скачать удалённый репозиторий необходимо использовать команду *git clone*. В терминале, в котором открыта любая пустая папка, необходимо написать *git clone <ссылка на репозиторий>*. Репозиторий скачатеся в папку, название которой будет совпадать с названием репозитория.

## Скачивание изменений с удалённого репозитория
Для того, чтобы скачать изменения с удалённого репозитория, необходимо использовать команду *git pull*. В терминале с  папкой с репозиторием, связанным с удалённым репозиторием, пишем *git pull origin <название ветки>* для того, чтобы принять изменения из указанной ветки удалённго репозитория в текущую ветку.

## Отправка изменений Github
Для отправки изменений в удалённый репозиторий необходимо использовать команду *git push*. Для этого в терминале с папкой с репозиторием, связанным с удалённым репозиторием, пишем команду *git push origin <название ветки>*, <название ветки> - это ветка в удалённом репозитори, куда необходимо отправить совершённые изменения

## Создание удалённого репозитория

  В случае, если я создал локальный репозиторий, и хочу закачать его на GitHub, для этого в своём аккаунте на GitHub необходимо создать новые репозиторий, и скопировать его ссылку (в кнопке Code).
  
  Затем в программе Git, находясь в папке моего локального репозитория, необходимо выполнить две команды:

  1. Git branch -M master 
  
  (где буква M обязательно большая), этой командой мы сообщаем, что в удалённом репозитории главной веткой назначается ветка master.

2. git remote add origin Ссылка-Скопированная-На-GitHub-На-Новый-Репозиторий

В дальнейшем, при обновлении и создании новых комитов на локальном репозитории, чтобы отправить новые изменения на удалённый репозиторий необходимо выполнить команду:

3. git push origin master

Если изменения/обновления вносились на удалённом репозитории непосредственно в GitHub, то необходимо закачать такие изменения в мой локальный репозиторий, чтобы локальная версия была актуальная - с помощью следующей команды:

4. git pull origin master
